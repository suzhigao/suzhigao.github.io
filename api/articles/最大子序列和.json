{"title":"最大子序列和问题","slug":"最大子序列和","date":"2020-04-18T05:17:46.000Z","updated":"2020-07-08T15:48:42.261Z","comments":true,"path":"api/articles/最大子序列和.json","excerpt":"求给定N个整数的序列{A1,A2,……,An},求函数 f(i,j)=max{0,∑(i→j)Ak}的最大值","covers":null,"content":"<p><strong>求给定N个整数的序列{A1,A2,……,An},求函数 f(i,j)=max{0,∑(i→j)Ak}的最大值</strong></p>\n<a id=\"more\"></a>\n\n<h3 id=\"算法1\"><a href=\"#算法1\" class=\"headerlink\" title=\"算法1\"></a>算法1</h3><p>直接暴力求出每个子序列和的值，然后取最大的值。<strong>时间复杂度为O(n^3)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubseqSum1</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ThisSum, MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j, k;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">for</span> (j = i; j &lt; N; j++) &#123;</span><br><span class=\"line\">\t            ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (k = i; k &lt;= j; k++)</span><br><span class=\"line\">\t\t  ThisSum += A[k];</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class=\"line\">\t\tMaxSum = ThisSum;<span class=\"comment\">//更新最大值</span></span><br><span class=\"line\">\t             &#125;</span><br><span class=\"line\">\t       &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br><br></p>\n<h3 id=\"算法2\"><a href=\"#算法2\" class=\"headerlink\" title=\"算法2\"></a>算法2</h3><p>在算法1的基础上进行优化，<strong>时间复杂度为O(n^2)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubseqSum2</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ThisSum, MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t     ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t     <span class=\"keyword\">for</span> (j = i; j &lt; N; j++) &#123;</span><br><span class=\"line\">\t           ThisSum += A[j];</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class=\"line\">\t         MaxSum = ThisSum;</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br><br></p>\n<h3 id=\"算法3：分而治之处理\"><a href=\"#算法3：分而治之处理\" class=\"headerlink\" title=\"算法3：分而治之处理\"></a>算法3：分而治之处理</h3><p>==时间复杂度为O(n^2)的可以想办法优化成O(n㏒n)==<br>递归分成两份，分别求每个分割后最大子列和，<strong>时间复杂度为 O(n*logn)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 返回三者中最大值*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max3</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (A &gt; B) ? ((A &gt; C) ? A : C) : ((B &gt; C) ? B : C);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 分治*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DivideAndConquer</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*递归结束条件：子列只有一个数字*/</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当该数为正数时，最大子列和为其本身</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当该数为负数时，最大子列和为 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left == right) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt; a[left])</span><br><span class=\"line\">                       <span class=\"keyword\">return</span> a[left];</span><br><span class=\"line\">\t       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 分别递归找到左右最大子列和*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> MaxLeftSum = DivideAndConquer(a, left, center);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> MaxRightSum = DivideAndConquer(a, center + <span class=\"number\">1</span>, right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 再分别找左右跨界最大子列和*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> MaxLeftBorderSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> LeftBorderSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = center; i &gt;= left; i--) &#123;  <span class=\"comment\">//应该从边界出发向左边找</span></span><br><span class=\"line\">\t      LeftBorderSum += a[i];</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (MaxLeftBorderSum &lt; LeftBorderSum)</span><br><span class=\"line\">\t         MaxLeftBorderSum = LeftBorderSum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> MaXRightBorderSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> RightBorderSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = center + <span class=\"number\">1</span>; i &lt;= right; i++) &#123;  <span class=\"comment\">// 从边界出发向右边找</span></span><br><span class=\"line\">\t      RightBorderSum += a[i];</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (MaXRightBorderSum &lt; RightBorderSum)</span><br><span class=\"line\">\t          MaXRightBorderSum = RightBorderSum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">/*最后返回分解的左边最大子列和，右边最大子列和，和跨界最大子列和三者中最大的数*/</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> Max3(MaxLeftSum, MaxRightSum, MaXRightBorderSum + MaxLeftBorderSum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubseqSum3</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> DivideAndConquer(a, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br><br></p>\n<h3 id=\"算法4-在线处理\"><a href=\"#算法4-在线处理\" class=\"headerlink\" title=\"算法4:在线处理\"></a>算法4:在线处理</h3><p>“贪心法”，即不从整体最优上加以考虑，只做出某种意义上的局部最优解。<br>其实最大子列和与它的首部和尾部都没有关系，我们只关心它当前的大小。<br>当临时和加上当前值为负时，它对之后子列和肯定没有帮助（甚至只会让之后的和更小！），<br>我们抛弃这段临时和将它置0。<strong>时间复杂度为O(n)</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubseqSum4</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> ThisSum = <span class=\"number\">0</span>, MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\tThisSum += A[i];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ThisSum &gt; MaxSum)</span><br><span class=\"line\">\t   MaxSum = ThisSum;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ThisSum &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t   ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"算法1\"><a href=\"#算法1\" class=\"headerlink\" title=\"算法1\"></a>算法1</h3><p>直接暴力求出每个子序列和的值，然后取最大的值。<strong>时间复杂度为O(n^3)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubseqSum1</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ThisSum, MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j, k;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t      <span class=\"keyword\">for</span> (j = i; j &lt; N; j++) &#123;</span><br><span class=\"line\">\t            ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (k = i; k &lt;= j; k++)</span><br><span class=\"line\">\t\t  ThisSum += A[k];</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class=\"line\">\t\tMaxSum = ThisSum;<span class=\"comment\">//更新最大值</span></span><br><span class=\"line\">\t             &#125;</span><br><span class=\"line\">\t       &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br><br></p>\n<h3 id=\"算法2\"><a href=\"#算法2\" class=\"headerlink\" title=\"算法2\"></a>算法2</h3><p>在算法1的基础上进行优化，<strong>时间复杂度为O(n^2)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubseqSum2</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ThisSum, MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\t     ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t     <span class=\"keyword\">for</span> (j = i; j &lt; N; j++) &#123;</span><br><span class=\"line\">\t           ThisSum += A[j];</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (ThisSum &gt; MaxSum) &#123;</span><br><span class=\"line\">\t         MaxSum = ThisSum;</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br><br></p>\n<h3 id=\"算法3：分而治之处理\"><a href=\"#算法3：分而治之处理\" class=\"headerlink\" title=\"算法3：分而治之处理\"></a>算法3：分而治之处理</h3><p>==时间复杂度为O(n^2)的可以想办法优化成O(n㏒n)==<br>递归分成两份，分别求每个分割后最大子列和，<strong>时间复杂度为 O(n*logn)</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 返回三者中最大值*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Max3</span><span class=\"params\">(<span class=\"keyword\">int</span> A, <span class=\"keyword\">int</span> B, <span class=\"keyword\">int</span> C)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (A &gt; B) ? ((A &gt; C) ? A : C) : ((B &gt; C) ? B : C);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 分治*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">DivideAndConquer</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*递归结束条件：子列只有一个数字*/</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当该数为正数时，最大子列和为其本身</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当该数为负数时，最大子列和为 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (left == right) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (<span class=\"number\">0</span> &lt; a[left])</span><br><span class=\"line\">                       <span class=\"keyword\">return</span> a[left];</span><br><span class=\"line\">\t       <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 分别递归找到左右最大子列和*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> center = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> MaxLeftSum = DivideAndConquer(a, left, center);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> MaxRightSum = DivideAndConquer(a, center + <span class=\"number\">1</span>, right);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 再分别找左右跨界最大子列和*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> MaxLeftBorderSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> LeftBorderSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = center; i &gt;= left; i--) &#123;  <span class=\"comment\">//应该从边界出发向左边找</span></span><br><span class=\"line\">\t      LeftBorderSum += a[i];</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (MaxLeftBorderSum &lt; LeftBorderSum)</span><br><span class=\"line\">\t         MaxLeftBorderSum = LeftBorderSum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> MaXRightBorderSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> RightBorderSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = center + <span class=\"number\">1</span>; i &lt;= right; i++) &#123;  <span class=\"comment\">// 从边界出发向右边找</span></span><br><span class=\"line\">\t      RightBorderSum += a[i];</span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (MaXRightBorderSum &lt; RightBorderSum)</span><br><span class=\"line\">\t          MaXRightBorderSum = RightBorderSum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">/*最后返回分解的左边最大子列和，右边最大子列和，和跨界最大子列和三者中最大的数*/</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> Max3(MaxLeftSum, MaxRightSum, MaXRightBorderSum + MaxLeftBorderSum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubseqSum3</span><span class=\"params\">(<span class=\"keyword\">int</span> a[], <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> DivideAndConquer(a, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br><br></p>\n<h3 id=\"算法4-在线处理\"><a href=\"#算法4-在线处理\" class=\"headerlink\" title=\"算法4:在线处理\"></a>算法4:在线处理</h3><p>“贪心法”，即不从整体最优上加以考虑，只做出某种意义上的局部最优解。<br>其实最大子列和与它的首部和尾部都没有关系，我们只关心它当前的大小。<br>当临时和加上当前值为负时，它对之后子列和肯定没有帮助（甚至只会让之后的和更小！），<br>我们抛弃这段临时和将它置0。<strong>时间复杂度为O(n)</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">MaxSubseqSum4</span><span class=\"params\">(<span class=\"keyword\">int</span> A[], <span class=\"keyword\">int</span> N)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> ThisSum = <span class=\"number\">0</span>, MaxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">\tThisSum += A[i];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ThisSum &gt; MaxSum)</span><br><span class=\"line\">\t   MaxSum = ThisSum;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ThisSum &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t   ThisSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MaxSum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":[],"tags":[{"name":"算法","path":"api/tags/算法.json"},{"name":"数据结构","path":"api/tags/数据结构.json"}]}